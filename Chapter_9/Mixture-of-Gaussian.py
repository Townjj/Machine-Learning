'''
chapter 9.4.3
page 206
hierarchical clustering 
Gaussian mixture clustering
'''

import random
import numpy as np
import matplotlib.pyplot as plt
from numpy import linalg

def load_data40():
    '''
    load watermelon data 4.0
    page202 , table9.1
    '''
    data40=['number','density','sugercontent',
    1,0.697,0.460,
    2,0.774,0.376,
    3, 0.634,0.264,
    4,0.608,0.318,
    5,0.556,0.215,
    6,0.403,0.237,
    7,0.481,0.149,
    8,0.437,0.211,
    9,0.666,0.091,
    10,0.243,0.267,
    11,0.245,0.057,
    12,0.343,0.099,
    13,0.639,0.161,
    14,0.657,0.198,
    15,0.360,0.370,
    16,0.593,0.042,
    17,0.719,0.103,
    18,0.359,0.188,
    19,0.339,0.241,
    20,0.282,0.257,
    21,0.748,0.232,
    22,0.714,0.346,
    23,0.483,0.312,
    24,0.478,0.437,
    25,0.525,0.369,
    26,0.751,0.489,
    27,0.532,0.472,
    28,0.473,0.376,
    29,0.725,0.445,
    30,0.446,0.459]
    data = np.array(data40,dtype=np.dtype).reshape(31,3)
    return data


def p(x,mu,mat):
    '''
    the **prior** probability of x_j generated by the i-th Gaussian mixture component
    '''
    return np.exp(-0.5*(x-mu).T@(np.linalg.inv(mat))@(x-mu))/(2*np.pi*(np.linalg.det(mat)**0.5))


def pm(data,alpha,mu,con_arr,i,j,k):
    '''
    the **posterior** probability of x_j generated by the i-th Gaussian mixture component
    simplified as y_arr[j,i]
    '''
    a = alpha[i]*p(data[j,1:],mu[i],con_arr[i,:,:])
    b = np.sum([alpha[l]*p(data[j,1:],mu[l],con_arr[l,:,:]) for l in range(k)])
    return a/b
    

def Gaussian_clustering(data,k,iteration=3):
    '''
    main function of Gaussian clustering algorithm
    data       | data with head and no.
    k          | num of clusters
    con_arr    | Covariance array
    '''
    m = len(data)-1 #m=30
    alpha = [(1/3)]* 3
    mu = [data[6,1:],data[22,1:],data[27,1:]]
    con_arr = np.array([[[0.1,0],[0,0.1]],[[0.1,0],[0,0.1]],[[0.1,0],[0,0.1]]])
    y_arr = np.zeros((m+1,k))
    print(pm(data,alpha,mu,con_arr,i=0,j=1,k=3))
    
    #update mu,alpha,con_arr
    while iteration:
        #E step of EM algorithm
        for j in range(1,m+1):
            for i in range(k):
                y_arr[j,i] = pm(data,alpha,mu,con_arr,i,j,k)

        #M step of EM algorithm
        for i in range(k):
            temp_i = np.sum([y_arr[j,i] for j in range(1,m+1)])

            ##updata mu[i]
            mu_i = 0
            for j in range(1,m+1):
                mu_i += y_arr[j,i]*(np.array(data[j,1:])) / temp_i
            mu[i] = mu_i

            ##update con_arr[i]
            con_arr_i = np.zeros((2,2),dtype=float)
            for j in range(1,m+1):
                con_arr_i = np.add(con_arr_i , y_arr[j,i]*(data[j,1:]-mu[i]).reshape(2,1)@(data[j,1:]-mu[i]).reshape(1,2)/temp_i )
            con_arr[i,:,:] = con_arr_i

            ## update alpha
            alpha[i] = temp_i/m
        #print('iteration = ',iteration,'alpha=',alpha,'\nmu=',mu,'\ncon_arr=',con_arr)
        iteration -= 1

    #padding Clusters
    Clusters = [[],[],[]]
    for j in range(1,m+1):
        label = np.argmax([y_arr[j,i] for i in range(k)])
        Clusters[label].append(j)
    return Clusters
    
def output(data,Clusters):
    '''
    to print & drawing result of DBSCAN
    data         | data with head and no.
    Clusters     | data's no. in each clusters
    drawing_data | above whole data in each clusters without head
    '''
    #print
    k = len(Clusters)
    print('DBSCAn result:')
    for i in range(k):
        print('>>>Cluster %d including'%i,Clusters[i])

    #drawing 
    drawing_data = []
    for i in range(k):
        drawing_data.insert(i ,np.array([data[j,1:3] for j in Clusters[i]],dtype=np.dtype))
    fig = plt.figure(figsize=(5,5))
    ax1 = fig.add_subplot(1,1,1)
    ax1.set_title('Gaussian Mixture (iteration=20)')
    dot0 = ax1.scatter(drawing_data[0][:,0],drawing_data[0][:,1],c='chocolate',s=2000,alpha=0.8)
    dot1 = ax1.scatter(drawing_data[1][:,0],drawing_data[1][:,1],c='c',s=2000,alpha=0.8)
    dot2 = ax1.scatter(drawing_data[2][:,0],drawing_data[2][:,1],c='blueviolet',s=2000,alpha=0.8)
    #dot3 = ax1.scatter(drawing_data[3][:,0],drawing_data[3][:,1],c='gold',s=2000,alpha=0.8)
    #dot4 = ax1.scatter(drawing_data[4][:,0],drawing_data[4][:,1],c='dimgray',s=150)
    plt.xlabel('density')
    plt.ylabel('sugercontent')
    plt.show()

#main function
data = load_data40()
k ,itration = 3 ,20
Clusters=Gaussian_clustering(data,k=k,iteration=itration)
output(data,Clusters)